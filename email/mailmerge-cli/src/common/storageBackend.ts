import {
    EmailString,
    ENGINES_MAP,
    getRecordPreviewPrefixForIndividual,
    getSidecarMetadata,
    loadPreviewsFromSidecar,
    loadSidecars,
    MappedRecord,
    SidecarData,
    TemplateEngineOptions,
    TemplatePreviews,
    writeMetadata,
    writeSidecarFile,
} from "@docsoc/libmailmerge";
import { createLogger, move } from "@docsoc/util";
import fs from "fs/promises";
import { mkdirp } from "mkdirp";
import { join } from "path";

/**
 * How we pass around the result of a merge on one record.
 *
 * This is the result of merging a single record with a template.
 */
export interface MergeResult {
    /** The record used to create this result */
    record: MappedRecord;
    /** The previews generated by the engine */
    previews: TemplatePreviews;
    /** Metadata about the engine used, so we can get it back later */
    engineInfo: {
        /** Engine used */
        name: string;
        /** Options given to the engine */
        options: TemplateEngineOptions;
    };
    /** Paths to attachments to include in the final email, likely relative to CWD */
    attachmentPaths: string[];
    /** Metadata for emailing */
    email: {
        to: EmailString[];
        cc: EmailString[];
        bcc: EmailString[];
        subject: string;
    };
}

/**
 * Object passed to the storage backend to store the result of a merge on one record.
 *
 * The point of this is to provide backends with a property to store their own data about the merge result,
 * specifically {@link MergeResultWithMetadata.storageBackendMetadata},
 * which will be passed back to them by us after processing the result (after e.g. a rerender)
 *
 * @template Metadata You're free to define your own metadata type for your storage backend, and pass it here to set the type of {@link MergeResultWithMetadata.storageBackendMetadata}
 */
export type MergeResultWithMetadata<Metadata = unknown> = MergeResult & {
    storageBackendMetadata: Metadata;
};

/**
 * Interface for a storage backend, which is responsible for loading and storing merge results.
 *
 * This is the interface you need to implement to store merge results in your own way.
 *
 * @template Metadata You're free to define your own metadata type for your storage backend, and pass it here to set the type of {@link MergeResultWithMetadata.storageBackendMetadata}
 */
export interface StorageBackend<Metadata = unknown> {
    /** Return an async iterator of merge results, loaded as you want */
    loadMergeResults(): AsyncGenerator<MergeResultWithMetadata<Metadata>>;
    /**
     * Store the original merge results back to the storage - called after it is first generated
     * @param results Results to save
     * @param rawData Data used - headers and the _mapped_ record used to generate the results - in case you find it useful
     */
    storeOriginalMergeResults(
        results: MergeResult[],
        rawData: { headers: Set<string>; records: MappedRecord[] },
    ): PromiseLike<void>;
    /**
     * Store updated merge results back to the storage.
     * Note that the metadata you provided in {@link MergeResultWithMetadata.storageBackendMetadata} will be passed back to you on that property
     *
     * Treat this as a complete update option (think PUT vs PATCH)
     */
    storeUpdatedMergeResults(results: MergeResultWithMetadata<Metadata>[]): PromiseLike<void>;
    /**
     * Called after a merge result has been sent, so that you can do any post processing.
     *
     * E.g. Move file around, mark as sent in database
     */
    postSendAction?(resultSent: MergeResultWithMetadata<Metadata>): PromiseLike<void>;
}

/** Metadata the JSON backend passes on {@link MergeResultWithMetadata.storageBackendMetadata} - bsically the original sidecar file with the path it came from */
interface JSONSidecarsBackendMetadata {
    sideCar: SidecarData & {
        /** Path to the original sidecar file */
        $originalFilepath: string;
    };
}

/**
 * Store the sidecar metadata for a record & the previews generated from it on the file system at {@link outputRoot}.
 *
 * Sidecar files here are JSON files placed next to the previews, containing metadata about the previews.
 */
export class JSONSidecarsBackend implements StorageBackend<JSONSidecarsBackendMetadata> {
    constructor(
        /** Root to load/store sidecar fils to */
        private outputRoot: string,
        /** How to name the files when outputting them: specifcally what to prefix with them */
        private fileNamer:
            | {
                  /** You already know the shape of a record, so can provide the namer upfront */
                  type: "fixed";
                  namer: (record: MappedRecord) => string;
              }
            | {
                  /** You need to know the shape of a record, so need to provide the namer later (e.g. by prompting the user how to construct it) */
                  type: "dynamic";
                  namer: (
                      headers: Set<string>,
                      records: MappedRecord[],
                  ) => PromiseLike<(record: MappedRecord) => string>;
              },
        private logger = createLogger("sidecar"),
    ) {}

    /**
     * Load all sidecar files from the output root, and the files associated with them and return them as merge results.
     */
    async *loadMergeResults(): AsyncGenerator<
        MergeResultWithMetadata<JSONSidecarsBackendMetadata>
    > {
        this.logger.info(`Loading previews from ${this.outputRoot}...`);
        // 1: Load all sidecars
        const sidecars = loadSidecars(this.outputRoot);
        // 2: Map sidecar files & rerender
        for await (const sidecar of sidecars) {
            const { name, engine: engineName, engineOptions, files, record } = sidecar;

            const EngineClass = ENGINES_MAP[engineName as keyof typeof ENGINES_MAP];
            if (!EngineClass) {
                this.logger.error(`Invalid template engine: ${engineName}`);
                this.logger.warn(`Skipping record ${name} as the engine is invalid!`);
                continue;
            }
            this.logger.debug("Remapping sidecar files metadata back to merge results...");
            this.logger.debug(JSON.stringify(files));
            const previews: TemplatePreviews = await loadPreviewsFromSidecar(
                files,
                this.outputRoot,
            );

            yield {
                record,
                previews,
                engineInfo: {
                    name: engineName as keyof typeof ENGINES_MAP,
                    options: engineOptions,
                },
                attachmentPaths: sidecar.attachments,
                email: sidecar.email,
                storageBackendMetadata: {
                    sideCar: sidecar,
                },
            };
        }
    }

    /**
     * Store the updated merge results back to the storage - called after they are rerendered
     */
    async storeUpdatedMergeResults(
        results: MergeResultWithMetadata<JSONSidecarsBackendMetadata>[],
    ): Promise<void> {
        for (const result of results) {
            const sidecar = result.storageBackendMetadata.sideCar;
            const { name } = sidecar;
            this.logger.info(`Writing rerendered previews for ${name}...`);
            await Promise.all(
                result.previews.map(async (preview, idx) => {
                    const file = sidecar.files[idx];
                    this.logger.debug(`Writing rerendered preview ${file.filename}...`);
                    await fs.writeFile(join(this.outputRoot, file.filename), preview.content),
                        this.logger.debug("Overwriting sidecar metadata with new metadata...");
                    sidecar.files[idx].engineData = {
                        ...preview,
                        content: undefined,
                    };
                }),
            );

            this.logger.info(
                `Updating sidecar metadata for ${name} at ${sidecar.$originalFilepath}...`,
            );
            await writeSidecarFile(sidecar.$originalFilepath, sidecar);
        }
    }

    /**
     * After send move the sent emails to a sent folder
     */
    async postSendAction(
        resultSent: MergeResultWithMetadata<JSONSidecarsBackendMetadata>,
    ): Promise<void> {
        const sidecar = resultSent.storageBackendMetadata.sideCar;
        const sentRoot = join(this.outputRoot, "sent");
        this.logger.info(`Moving sent emails for ${sidecar.name} to ${sentRoot}...`);
        await mkdirp(sentRoot);
        await Promise.all(
            sidecar.files.map(async (file) => {
                await move(join(this.outputRoot, file.filename), sentRoot);
            }),
        );
    }

    /**
     * Store results - see {@link getRecordPreviewPrefixForIndividual} for how the previews are named
     */
    async storeOriginalMergeResults(
        results: MergeResult[],
        { headers, records }: { headers: Set<string>; records: MappedRecord[] },
    ): Promise<void> {
        this.logger.warn(`Writing previews to ${this.outputRoot}...`);
        let fileNamer: (record: MappedRecord) => string;
        if (this.fileNamer.type === "fixed") {
            fileNamer = this.fileNamer.namer;
        } else {
            fileNamer = await this.fileNamer.namer(headers, records);
        }
        this.logger.debug("Creating directories...");
        await mkdirp(this.outputRoot);
        this.logger.debug("Writing files...");
        await Promise.all(
            results.flatMap(
                async ({ previews, record, engineInfo, attachmentPaths: attachmentPath }) => {
                    const operations = previews.map(async (preview) => {
                        const fileName = getRecordPreviewPrefixForIndividual(
                            record,
                            fileNamer,
                            engineInfo.name,
                            preview,
                        );
                        this.logger.debug(`Writing ${fileName}...`);
                        await fs.writeFile(join(this.outputRoot, fileName), preview.content);
                    });

                    // Add metadata write operation
                    operations.push(
                        writeMetadata(
                            record,
                            getSidecarMetadata(
                                fileNamer,
                                record,
                                engineInfo.name,
                                engineInfo.options,
                                attachmentPath,
                                previews,
                            ),
                            fileNamer,
                            this.outputRoot,
                        ),
                    );

                    return operations;
                },
            ),
        );

        this.logger.info(`Done! Review previews at ${this.outputRoot} and then send.`);
    }
}
